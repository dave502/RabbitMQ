#### Составляющие кадра (frame) AMQP
кадр AMPQ нижнего уровня составляется из пяти различных компонентов:
1. Типа кадра
2. Номера канала
3. Размера кадра в байтах
4. Полезной нагрузки кадра
5. Маркера завершающего байта (ASCII значение 206)
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230619135606.png)
#### Типы кадров протокола AMQP

Спецификация AMQP определяет пять типов кадров: кадр заголовка протокола, кадр метода, кадр заголовка содержимого, кадр тела и кадр сердцебиения. Каждый тип кадра имеет некую отличительную цель, причём какие- то из них применяются гораздо чаще остальных:

- Кадр заголовка протокола применяется всего лишь один раз, а именно при соединении с RabbitMQ.
- Кадр метода несёт в себе определённый запрос RPC или отклик, который отправляется или получается от RabbitMQ.
- Кадр заголовка содержимого содержит размер и свойства некоторого сообщения.
- Кадры тела собственно и составляют сообщения.
- Кадр сердцебиения отправляется в сторону RabbitMQ и от него в качестве проверки обеспечения того, что обе стороны соединения доступны и работают надлежащим образом.
#### Публикация сообщений
При публикации некоторого сообщения в RabbitMQ, оно составляется из трёх типов кадров нижнего уровня: кадры метода, заголовка и тела. Самым первым отсылаемым кадром является кадр метода, несущий саму команду и параметры для её исполнения, такие как имя exchange и ключ маршрута. Вслед за кадром метода идут кадры содержимого: заголовка содержимого и тела. Кадр заголовка содержимого заключает необходимые свойства сообщения (тип содержимого сообщения и значение времени, когда это сообщение было отправлено) вместе с размером его тела. Эти свойства заключаются в некую структуру данных, определяемую в спецификации AMQP как `Basic.Properties`. AMQP имеет некий максимальный размер кадра (по умолчанию 131 кБ) и если размер тела вашего сообщения превосходит это размер, всё содержимое будет расщепляться на множество кадров тела. Эти кадры всегда отправляются в одном и том же порядке по проводу: кадр метода, кадр заголовка содержимого и один или более кадров тела
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230620144946.png)
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230619140529.png)
Содержимое в кадре метода и кадре заголовка содержимого представляет собой упакованную бинарную информацию.
#### Содержимое кадра метода 
Кадры метода переносят в себе значения класса и метода вашего запроса RPC, который следует сделать, а также аргументы, которые одновременно передаются для обработки. 
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230619142130.png)
Значение кадра метода, переносящего команду `Basic.Publish`  состоит из пяти компонентов. Первые два поля являются численным представлением имени класса `Basic` и названия метода `Publish`. За этими полями следуют строковые значения названия необходимого exchange и  ключа маршрутизации. Значение флага `mandatory` сообщает RabbitMQ что данное сообщение должно быть доставлено с подтверждением или публикацию этого сообщения следует сбросить.



#### Содержимое кадра заголовка 
В заголовке может содержаться таблица `Basic.Properties`, содержащая данные, которые описывают передаваемое содержимое сообщения (может быть пустой). Большинство библиотек клиента предварительно заполняют некий минимальный набор полей, такие как тип содержимого и режим доставки.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230619143916.png)

#### Содержимое кадра body
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230619144206.png)

#### Описание exchange
Exchange создаются при помощи команды `Exchange.Declare`, которая имеет аргументы, определяющие имя этого обмена, его тип и прочие метаданные, которые могут применяться для обработки сообщения.
После отправки команды и создания RabbitMQ необходимого обмена в ответ отправляется некий кадр метода `Exchange.DeclareOk`. 
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230619144607.png)
Если по какой- либо причине exchange не будет создан, RabbitMQ закроет тот канал, который отправил команду `Exchange.Declare` путём передачи команды `Channel.Close`. Такой отклик будет содержать некий численный код и текстовое значение, указывающие почему не выполнился `Exchange.Declare` и данный канал был закрыт.
#### Описание очереди (Queue)
После создания обмена самое время создать некую очередь отправив в RabbitMQ команду `Queue.Declare`. Как и для команды `Exchange.Declare`, это  простая последовательность взаимодействия 
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230619145057.png)
В случае возникновения отказа команды `Queue.Declare` данный канал будет закрыт.
При попытке объявления какой- то очереди с отличающимися свойствами от тех, которые имеются у очереди с точно таким же названием, RabbitMQ закроет тот канал, в котором был запущен этот запрос RPC.

#### Связывание (binding) очереди с exchange
Когда созданы необходимые обмен и очередь наступает время связать их воедино. Команда для связывания очереди с неким обменом, `Queue.Bind`, может за раз определять только одну очередь. Также как и в случае с командами `Exchange.Declare` и `Queue.Declare`, после выпуска команды `Queue.Bind` ваше приложение получит кадр метода `Queue.BindOk` если она будет обработана успешно
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230619145551.png)

#### Публикация сообщения в RabbitMQ
При публикации какого- то сообщения в RabbitMQ отправляются по крайней мере три кадра: кадр метода `Basic.Publish`. кадр заголовка содержимого и кадр тела
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230619145725.png)
Когда RabbitMQ получит все необходимые сообщению кадры, он прочитает информацию из кадра метода для определениея последующих шагов. Кадр метода `Basic.Publish` несёт в себе название требуемого exchange и ключ маршрутизации для данного сообщения. RabbitMQ попытается установить соответствие полученного в данном кадре `Basic.Publish` имени exchange в собственной базе данных exchanges.
<p class="note" >По умолчанию, если публикуется сообщение в exchange, который не существует в настройках rabbitMQ, то это сообщение незаметно удалится. Чтобы гарантировать доставку сообщения, необходимо либо установить флаг mandatory в значение истины при публикации, либо применить подтверждение доставки. Но применение любого из этих методов может отрицательно воздействовать на скорость публикации данного сообщения приложением.</p>
После того как RabbitMQ находит exchange c соответствующим названием, он определяет какое связывание в этом обмене и отыскивает соответствующие установленному ключу маршрутизации очереди. В случае когда критерий для сообщения соответствует каким-либо привязанным очередям, сервер RabbitMQ выдаст это сообщение в очередь по правилу FIFO. Вместо помещения реального сообщения в некую структуру данных очереди в эту очередь добавляется ссылка на такое сообщение. Когда RabbitMQ будет готов к доставке данного сообщения, он воспользуется данной ссылкой чтобы составить упорядоченное (marshaled) сообщение и отправить его. 
<p class="note">Удерживание только одного экземпляра занимает меньше памяти при его публикации для множества получателей. Размещение некоторого сообщения в очереди, будь то очередь потребления, просроченных сообщений или простоя, не повлияет на расположение в любой другой очереди. После того как RabbitMQ перестанет нуждаться в данном сообщении по причине доставки всех имеющихся у него копий или его удаления, данная единственная копия этого сообщения будет удалена из памяти в RabbitMQ.</p>
По умолчанию, до тех пор пока никакие потребители не будут прослушивать данную очередь, сообщения будут храниться в этой очереди. По мере добавления новых сообщений эта очередь растёт в размере. RabbitMQ может хранить эти сообщения в оперативной памяти или записывать их на диск в зависимости от свойства `delivery-mode`, определяемого в `Basic.Properties` данного сообщения. 
#### Потребление сообщений из RabbitMQ
После того как опубликованное сообщение снабжено маршрутом и поставлено в очередь в одной или более очередях, оно начинает ждать получателя. Для получения сообщений из очереди в RabbitMQ, некое получающее приложение подписывается на соответствующую очередь в RabbitMQ выполняя команду `Basic.Consume`. Как и в случае с прочими синхронными командами, сервер ответит `Basic.ConsumeOk` чтобы позволить данному клиенту знать о том, что он собирается отправить сообщения. Далее сервер отправлет кадр метода `Basic.Deliver`, кад заголовка содержимого и кадры body.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230619155238.png)
После вызова `Basic.Consume`, клиент будет оставаться активным, пока не произойдёт одно из событий:
- потребитель вызовет команду `Basic.Cancel` (потребитель может ещё получить некоторое число сообщений, которые RabbitMQ отправил ему прежде чем получил команду `Basic.Cancel` и вернул кадр отклика `Basic.CancelOk`)
При получении сообщений имеются некоторые установки, которые позволяют дать знать RabbitMQ о том как потребитель желает получать их. Одной из таких настроек является аргумент `no_ack` для команды `Basic.Consume`. Когда он установлен в значение истины, RabbitMQ будет отправлять сообщения непрерывно до тех пор, пока имеющийся потребитель не отправит команду `Basic.Cancel` или этот потребитель не отсоединится. Если же значение флага `no_ack` установлено в значение ложь, потребитель обязан подтверждать приём каждого принимаемого им сообщения, отправляя некий запрос RPC `Basic.Ack`
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230619160251.png)
При отправке кадра отклика `Basic.Ack` потребитель должен передать с ним аргумент из кадра метода `Basic.Deliver`, именуемый как **delivery tag** (маркер доставки). RabbitMQ использует данный маркер доставки помимо номера канала в качестве уникального идентификатора для координации взаимодействия сообщений, их отклонения и отрицания подтверждения приёма.
#### Basic.Properties
Все содержащиеся в кадре заголовка свойства сообщения являются набором значений, определяемых структурой данных `Basic.Properties`. Некоторые свойства, такие как `delivery-mode` имеют значения, определённые в спецификации AMQP, в то время как другие, например `type`, не имеют точного определения.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230620145532.png)
Значения базовых свойств:
- `content-type` позволяет пользователю понять как интерпретировать тело сообщения
- `content-encoding` указывает, что тело данного сообщения может быть сжато или закодировано неким особым образом
- `message-id` и `correlation-id` уникально идентифицируют сообщения и отклики на сообщение, отслеживая данное сообщение в рабочем потоке
- `timestamp` уменьшает размер сообщения и создаёт определение того когда было создано сообщение
- `expiration` определяет срок истечения времени жизни сообщения 
- `delivery-mode` указывает RabbitMQ хранить ли сообщения очереди на диске или в оперативной памяти 
- `app-id` и `user-id` помогает выявлять проблемных издателей
- `type` определяет некий контракт (спецификацию для формата и содержимого сообщений) издателей с потребителями
- `reply-to` обеспечивает маршрутизацию откликов сообщений при реализации шаблона
- `headers` применяются для свободной формы определений свойств и маршрутизации RabbirMQ
Свойство `content-type` описывает тип MIME тела своего сообщения. Если приложение отправляет данные в виде JSON, установив значение свойства `content-type` в `application/json`, это позволит получателю корректным образом декодировать данное сообщение.

Свойство `content-encoding` применяется для хранения MIME кодировки содержимого. Отправляемые через AMQP сообщения по умолчанию не сжимаются. И это может стать проблемой при больших сообщениях, например, формата XML, JSON или YAML. Но издатели могут сжимать сообщения до их публикации и распаковывать их при получении, подобно тому, как веб-страницы могут быть сжаты на сервере с помощью gzip, а браузер может распаковывать их на лету. Если размер сообщения воздействует на общую производительность и стабильность, то его заголовок `content-encoding` позволит потребителям заранее квалифицировать сообщения, гарантируя что они смогут декодироваться из какого бы то ни было формата.

Свойства `message-id` и `correlation-id` могут применяться для отслеживания персональных сообщений и сообщений откликов по мере их прохождения в системе. Оба поля допускают до 255 байт закодированных UTF-8 данных и хранят несжатые значения, встраиваемые в структуру данных `Basic.Properties`. Их можно использовать в своих целях по усмотрению. Свойство `message-id` позволяет данному сообщению переносить в своём заголовке данные, которые уникальным образом его идентифицируют. Хотя формальное определение для `correlation-id` в имеющейся спецификации AMQP отсутствует, оно используется для указания того, что данное сообщение является откликом на другое сообщение, и значение `message-id` относится к тому сообщению. Другим вариантом является его применение для переноса некоего идентификатора транзакции или иных аналогичных данных, которые могут относиться к определённому сообщению.

Свойство `timestamp` одно из наиболее полезных полей в `Basic.Properties`. Используя значение свойства `timestamp` для указания того, когда сообщение было создано, потребители могут определять производительность доставки сообщения, а также  принимать решение, будут ли они обрабатывать сообщение, отклонят его или могут даже опубликовать предупреждающее сообщение в приложении мониторинга, что возраст сообщения превышает желаемое значение. Значение `timestamp` отправляется как эпоха Unix (8 байт). Для значений `timestamp` нет контекста временной зоны, поэтому предлагается применять UTC или иную подходящую зону времени одинаковую для всех сообщений. Устанавливая стандарт часового пояса, можно избежать проблем в будущем, которые могут возникнуть из-за путаницы часовых поясов у географически распределённых брокеров RabbitMQ.

Свойство `expiration` сообщает RabbitMQ когда стоит отменить сообщение если оно не было потреблено. Для использования свойства `expiration` необходимо установить необходимое строковое значение для мременного штампа Unix, обозначающее максимальное значение, для которого данное сообщение всё ещё остаётся в силе.

Свойство `delivery-mode` указывает RabbitMQ должен ли он сохранять получаемое сообщение на диск при размещении его в очереди, или он может оставлять его только в оперативной памяти. В RabbitMQ сохранение (persisting) некоторого сообщения означает, что оно будет оставаться в данной очереди пока не будет получено, даже в случае перезапуска сервера RabbitMQ. Данное свойство `delivery-mode` имеет два возможных значения: `1` для не оставляемых сообщений и `2` для оставляемых сообщений. Хотя сохранение сообщений на диске предоставляет некую гарантию того, что они не будут утрачены в случае краха брокера обмена сообщениями, это влечёт за собой потенциальные трудности с производительностью и масштабированием.

Свойства `app-id` и `user-id` предоставляютдополнительную информации о сообщении и имеют множество потенциальных применений. 
Свойство `app-id` определяется в спецификации AMQP как строка, допускающая до 255 символов UTF-8. Если приложение представляет собой API архитектуру с поддержкой версий, то можно использовать свойство `app-id` для отправки версии API, которая применялась при создании данного сообщения. Можно также использовать в качестве метода усиления контракта между издателем и потребителем, опрашивая свойство `app-id` перед тем как выполнить обработку и отвергать полученное сообщение если оно происходит от неизвестного или не поддерживаемого источника. Другое возможное применение для `app-id` состоит в сборе статистических данных. Например, если сообщения используются для переправки событий регистрации, можно установить свойство `app-id` для платформы и версии того приложения, которое выполнило регистрацию. Также `app-id` может использоваться для отслеживания издателя сообщения.

Свойство `type` является значением строки в свободном виде, которое может применяться для определения описания содержимого сообщения. Например, вместо формата JSON и XML можно использовать некий формат упорядочения, такой как [Apache Thrift](http://thrift.apache.org/) или [Google Protobuf](https://code.google.com/p/protobuf/), который требует внешнего файла для описания формата упорядочения. В этом случае свойство `type` можно использовать для указания типа записи или файла внешнего определения, что позволяет потребителю отклонять сообщения, которые он не сможет обработать или если он не имеет доступа к соответствующему файлу .thrift или .proto, который требуется для обработки данного сообщения. Также свойство `type` можно использовать когда ETL обрабатывает множество типов сообщений и использует имеющееся свойство `type` для принятия решения о том, в какой системе, таблице или кластере сохранять выделяемые данные.

Свойство `reply-to` не имеет формального определения и может использоваться по усмотрению, однако, согласно спецификации AMQP, `reply-to` может нести некий ключ маршрутизации или название очереди, которые могут применяться для откликов на данное сообщение, поэтому это свойство лучше использовать с осторожностью.

Свойство `headers` является таблицей ключ/ значение, которое допускает произвольные, определяемые пользователем ключи и значения. Ключи могут быть строками ASCII или Unicode, которые имеют максимальную длину в 255 символов. Значения могут быть любым допустимым типом значения AMQP.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230620162533.png)
В отличии от прочих свойств, данное свойство `headers` позволяет добавлять любые данные. Оно также имеет и иное уникальное свойство: RabbitMQ может маршрутизировать сообщения но основе тех значений, которыми заполнен такой `headers` вместо того, чтобы полагаться на имеющийся ключ маршрутизации. 

Поле `priority` определяется в спецификации AMQP как некое целое число с возможными значениями от 0 до 9 для установки приоритета сообщения в очереди. Если публикуется некое сообщение с приоритетом 9, а вслед за ним публикуется сообщение с приоритетом 0, вновь подключающийся потребитель получит сообщение, которое имеет приоритет 0 прежде чем сообщение с приоритетом 9. Занимательно, что RabbitMQ реализует это поле `priority` как байтовое значение без знака, поэтому приоритетами могут быть значения от 0 до 266, однако для сопровождения возможности взаимодействия сетевых сред в соответствии со спецификацией применяемое значение приоритета следует ограничивать в пределах от 0 до 9.

Свойство `cluster-id`  было зарезервировано в AMQP 0-9-1 и его не следует применять.

| Свойство | Тип | Область применения | Применение |
| :------: | :------: | :------: | :------: | 
| **`app-id`** | **`short-string`** | Приложение |Полезно для задания приложения, опубликовавшего данные сообщения|
| **`content-encoding`** | **`short-string`** | Приложение |Определяет кодируется ли тело сообщения особым образом, например, с помощью zlib, deflate или Base64|
| **`content-type`**| **`short-string`** | Приложение |Определяет тип данного сообщения с использованием типа MIME|
| **`correlation-id`** | **`short-string`** | Приложение |Если данное сообщение ссылается на некое другое сообщение, `correlation-id` является хорошим способом указания на него|
| **`delivery-mode`** | **`octet`** | RabbitMQ |Значение `1` сообщает RabbitMQ, что тот может оставлять данное сообщение в оперативной памяти, `2` указывает что его следует записать на диск.|
|**`expiration`** | **`short-string`** | RabbitMQ |Значение штампа времени эпохи Unix в виде текстовой строки, которое указывает когда истекает срок действия данного сообщения|
|**`headers`** | **`table`** | Оба |Таблица ключ/значение в произвольном виде, которую можно применять для добавления дополнительных метаданных о сообщении; При необходимости, RabbitMQ может выполнять маршрутизацию на основании headers|
| **`message-id`** | **`short-string`** | Приложение |Уникальный идентификатор, такой как UUID, который приложение может применять для идентификации сообщения.|
| **`priority`** | **`octet`** | RabbitMQ |Свойство для определения значения приоритета в очередях|
| **`timestamp`** | **`timestamp`** | Приложение |Значение временного штампа Unix, которое может применяться для указания времени создания сообщения|
| **`type`** | **`short-string`** | Приложение |Строка, которую приложение может применять для описания типа сообщения или его полезной нагрузки.|
| **`user-id`** | **`short-string`** | Оба |Строка в произвольном виде, которую, если она используется, RabbitMQ будет проверять для сопоставления с подключённым пользователем и удалять данное сообщение в случае несоответствия.|

### Балансировка между скоростью доставки и гарантией доставки
В RabbitMQ всякий спроектированный для создания гарантий доставки механизм привносит с собой воздействие на производительность. Когда они применяются сами по себе, можно и не заметить значительной разницы в пропускной способности, однако в случае их комбинированного использования влияние на пропускную способность будет существенным. Только выполнив  собственное тестирование производительности можно определить приемлемый компромисс между эффективностью и гарантированной доставкой.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230621085259.png)
Если недоставленное сообщение публиковалось с параметром `mandatory=True`, RabbitMQ возвращает его через RPC обратного вызова `Basic.Return` отправлявшему его клиенту. `Basic.Return` яляется неким асинхронным вызовом из RabbitMQ и он может произойти в любой момент времени после публикации сообщения.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230621090216.png)
```python
# Send a message
try:
    channel.basic_publish(exchange='test',
                          routing_key='test',
                          body='Hello World!',
                          properties = pika.BasicProperties(content_type = 'text/plain', 
                          delivery_mode = pika.DeliveryMode.Transient),
                          mandatory=True)
    print('Message was published')
except pika.exceptions.UnroutableError:
    print('Message was returned')
```
Другой способ работы с сообщениями, непрошедшими маршрутизацию, - использование Publisher Confirms. Прежде чем публиковать любое сообщение, издатель сообщения должен выпустить запрос RPC `Confirm.Select` в сторону RabbitMQ и ожидать отклика `Confirm.SelectOk` чтобы быть уверенным что подтверждения доставки включены. С этого момента, для каждого сообщения, которое продюсер отправит RabbitMQ, его сервер будет отвечать подтверждающим откликом (`Basic.Ack`) или отрицанием его (`Basic.Nack`)
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230621095344.png)
Альтернативные exchange являются ещё одним способом обработки не выполнивших маршрутизацию сообщений. Когда не выполнившее маршрутизацию сообщение опубликовано в каком-то exchange, который имеет некий альтернативный exchange, оно затем будет отправлено по маршруту через такой альтернативный exchange.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230621100955.png)
<p class="note">Если для сообщения установлен флаг `mandatory` при его отправке в некий exchange с альтернативным обменом, для данного издателя не будет использоваться `Basic.Return` если первичный предназначенный для этого обмен не смог выполнить маршрутизацию данного сообщения обычным образом.</p>
Необходимо добавить аргумент `alternate-exchange` в команде `Exchange.Declare`.
``` python
args = {'alternate-exchange': alternate_exchange_name}  
```
Прежде чем появились подтверждения доставки, единственным способом, который мог бы гарантировать доставку было использование транзакций. Транзакция AMQP, или `TX`, класс, предоставляет механизм, посредством которого может выполняться публикация RabbitMQ в пакетах и затем фиксироваться в какой-то очереди или откатываться назад (https://pika.readthedocs.io/en/stable/modules/channel.html?highlight=Transaction#pika.channel.Channel.tx_commit). Чтобы начать транзакцию, издатель отправляет в RabbitMQ запрос RPC `TX.Select`, а RabbitMQ ответит откликом `TX.SelectOk`. Когда данная транзакция открыта, её издатель может оправить в RabbitMQ одно или более сообщений. Если RabbitMQ не может осуществить маршрутизацию некоторого сообщения по причине ошибки, например, в случае не существующего exchange, он возвратит это сообщение в отклике `Basic.Return` прежде чем отправить отклик `TX.SelectOk`. Те издатели, которые пожелают прервать транзакцию, должны отправить запрос RPC `TX.Rollback` и ожидать отклика `TX.RollbackOk` от своего брокера, прежде чем продолжить.
В архитектурах с критически важными сообщениями важную роль играют очереди с высокой доступностью (HA queues). Очереди HA - расширение созданное командой RabbitMQ, которое не является частью имеющейся спецификации AMQP. Такие очереди имеют избыточные копии на множестве серверов и требуют кластерной среды. Когда сообщение публикуется в очередь, которая установлена как очередь с высокой доступностью, оно отправляется на каждый сервер в имеющемся кластере, который ответственен за эту очередь. После того как сообщение будет получено с любого из узлов в данном кластере, все копии данного сообщения будут немедленно удалены со всех прочих узлов. Очереди HA могут распространяться на все серверы в некотором кластере или только на индивидуальные узлы. Для определения индивидуальных узлов вместо передачи в аргументе `x-ha-policy: all`, необходимо передать в аргументе `x-ha-policy: nodes`, а затем другой аргумент, `x-ha-nodes`, содержащий перечень всех узлов, для которых следует настроить данную очередь.
```python
arguments={'x-ha-policy': 'all'} # для всех серверов
arguments = {'x-ha-policy': 'nodes', # для выборочных узлов
			 'x-ha-nodes': ['rabbit@node1',
							'rabbit@node2',
							'rabbit@node3']}
```
Если брокер RabbitMQ прекратит работу по какой-либо причине, сообщения в очереди будут утрачены навсегда, если не сообщить RabbitMQ при публикации сообщения, что его необходимо сохранить (persist) на диск пока оно находится в очереди. Если сообщение имеет `delivery-mode` установленным в `1`, что определено по умолчанию, то RabbitMQ будет хранить сообщение в оперативной памяти на протяжении всего времени. И если RabbitMQ перезапустится, такие сообщения будут утрачены. Когда `delivery-mode` установлен в значение `2`, RabbitMQ все сообщения будет сохранять на диск. И если RabbitMQ будет перезапущен, то сообщения останутся в очереди. Помимо значения `2` для `delivery-mode`, для гарантированного выживания сообщений при перезапуске брокера RabbitMQ, очереди должны быть объявлены как **durable** (долговременные) при их создании. Для серверов, не имеющих достаточной производительности ввода/ вывода, сохранение сообщений может вызвать большие проблемы с производительностью. RabbitMQ записывает сохраняемые сообщения на диск и отслеживает ссылки на них пока они не исчезнут из всех очередей. Когда все ссылки на сообщение завершаются, RabbitMQ удаляет такое сообщение с диска. При этом сильный уклон идёт в сторону записи, что нужно учесть при настройке оборудования. В экстремальных ситуациях задержки ввода/ вывода, вызываемые неверно подобранным оборудованием могут приводить к потере сообщений.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230621124839.png)
В случае, когда издатель отправляет в RabbitMQ слишком быстро и слишком много сообщений, чтобы защититься от перенасыщения RabbitMQ применяет TCP Backpressure. Для избежания таких ситуаций, при создании connection в pika можно использовать параметр [backpressure_detection](https://pika.readthedocs.io/en/stable/intro.html?highlight=Backpressure#tcp-backpressure)  или [add_on_connection_blocked_callback](https://pika.readthedocs.io/en/stable/modules/adapters/blocking.html?highlight=add_on_connection_blocked_callback#pika.adapters.blocking_connection.BlockingConnection.add_on_connection_blocked_callback) . Внутри RabbitMQ использует понятие кредитов для управления соединением с продюсером. Когда выполняется новое соединение, на это соединение выделяется определённое количество кредитов, которое он может использовать. По мере приёма каждой команды RPC со стороны RabbitMQ, кредит уменьшается. После того, как запрос RPC был обработан в RabbitMQ, соединение получает кредит обратно. Кредитный баланс соединения оценивается RabbitMQ чтобы определить, следует ли выполнять считывание из его сокета. Если соединение вышло за предел кредитования, оно просто пропускается, пока у него не станет достаточно кредитов. При достижении пороговых значения для соединения, RabbitMQ сообщает клиенту о том, что его соединение было заблокировано. `Connection.Blocked` и `Connection.Unblocked` являются асинхронными методами, которые могут отправляться в любой момент времени для уведомления о блокировке или разблокировке клиента. 

Чтобы получить состояние некоторого канала, можно использовать API. Для запроса используется адрес `http://host:port/api/channels/[CHANNEL_NAME]`, где CHANNEL_NAME - имя канала, которое строится по принципу `"LOCAL_ADDR: PORT -> REMOTE_ADDDR: PORT (CHANNEL_ID)"`. API управления возвратит результат в виде JSON объекта.
### Сопоставление Basic.Get и Basic.Consume
RabbitMQ реализует две различные команды AMQP RPC для выборки сообщений из очереди: `Basic.Get` и `Basic.Consume`. `Basic.Get` не является идеальным способом для выборки сообщений с сервера. Для упрощения терминологии, `Basic.Get` является моделью опроса (polling), в то время как `Basic.Consume` представляет собой модель с активным источником данных (активная доставка, push).
Когда приложение применяет для выборки сообщений запрос `Basic.Get`, оно должно отправлять запрос всякий раз когда желает получить некое сообщение, даже если в его очереди имеется множество сообщений. Если в очереди, из которой производится выборка, есть сообщения, то при вызове `Basic.Get` RabbitMQ ответит RPC откликом `Basic.GetOk` и соответствующим сообщением.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230622152324.png)
Если при вызове RPC запроса `Basic.Get` нет доступных сообщений, RabbitMQ ответит `Basic.GetEmpty`.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230622152420.png)
При использовании `Basic.Get` приложение должно оценивать полученный от RabbitMQ отклик RPC чтобы определить было ли получено сообщение. 
Хотя это самый простой способ взаимодействия с RabbitMQ для выборки сообщений, во многих случаях его производительность будет по крайней мере вдвое медленне чем при использовании `Basic.Consume` .
Потребляя сообщения при помощи команды `Basic.Consume`, приложение регистрируется в RabbitMQ и сообщает о необходимости отправлять ему сообщения асинхронно по мере того как они становятся доступными. Обычно это именуется как шаблон подписки на публикацию (publish-subscribe pattern) или pub-sub. Вместо ведения синхронного общения с RabbitMQ, которое происходит при `Basic.Get`, потребление сообщений с помощью `Basic.Consume` означает, что приложение автоматически получает сообщения от RabbitMQ по мере того как они становятся доступными клиент не вызовет `Basic.Cancel`.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230622153015.png)
Когда приложение вызывает `Basic.Consume`, создаётся уникальная строка, которая указывает на это приложение в соответствующем открытым канале в RabbitMQ. Эта строка, именуемая Тегом потребителя (consumer tag), отправляется в приложение при отправке каждого сообщения из RabbitMQ.
Как и при публикации сообщений, в потреблении сообщений имеются компромиссы в балансе пропускной способности и гарантией доставки.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230622153950.png)
При потреблении сообщений приложения регистрируют себя в RabbitMQ и запрашивают доставку сообщений по мере того как они становятся доступными. При регистрации приложения отправляют RPC запрос `Basic.Consume`, в котором может содержаться флаг `no-ack`. Когда этот флаг включён, он сообщает RabbitMQ что потребитель не нуждается в подтверждении сообщений и RabbitMQ должен всего лишь отправлять их настолько быстро, насколько это возможно. Потребление сообщений с `no_ack=True` является самым быстрым способом получения доставки сообщений потребителю, но это и самый ненадёжный способ доставки сообщений.

Спецификация AMQP требует настройки качества обслуживания (QoS) каналов чтобы потребитель мог запросить заранее установленное количество сообщений, которые он получит прежде чем выдаст подтверждение приёма. Такие установки QoS позволяют RabbitMQ более эффективно отправлять сообщения, указывая сколько сообщений предназначено для данного потребителя.
В отличии от потребителя с отключённым уведомлением получения (`no_ack=True`), если потребляющее приложение рушится после того как оно может подтвердить получение этих сообщений, все предварительно выбранные сообщения будут возвращены в установленную очередь при закрытии соответствующего сокета.
```python
# указать Rabbit не давать больше одного сообщения за раз (дождаться получения acknowledgement)
channel.basic_qos(prefetch_count=1)
```
<p class="note">Хотя спецификация AMQP требует и количества предварительно выбираемых сообщений и их размера для своего метода `Basic.QoS`, если установлена опция `no-ack`, размер предварительной выборки игнорируется.</p>
Высокое значение prefetch_count может оказывать отрицательное воздействие на пропускную способность сообщений. Важно производить эталонное тестирование производительности при изменении числа prefetch_count.
В отклике RPC `Basic.Ack` имеется атрибут `multiple` и когда он установлен в значение `True`, он позволяет RabbitMQ знать что ваше приложение хотело бы заверить получение всех предыдущих не получивших подтверждения в получении сообщений.
Такой тип выдачи подтверждений приёма несёт с собой определённый уровень риска. Если было успешно обработали какое- то число сообщений, а приложение упало прежде чем подтвердить это, все неподтверждённые сообщения возвратятся в свою очередь для обработки другим потребляющим их процессом.

Как и в случае с публикацией сообщений в RabbitMQ, транзакции позволяют потребляющим приложениям выполнять фиксацию или откат пакетов операций. Транзакции (класс `TX` AMQP) могут иметь некое отрицательное воздействие на пропускную способность за единственным исключением. Если не применять установки QoS, то можно будет увидеть лёгкое улучшение при использовании транзакций при пакетной обработке подтверждений приёма сообщений. Транзакции не работают для потребителей с отключёнными подтверждениями получения.

### Отклонение сообщений
Выдача подтверждений в получении является великолепным способом гарантировать что RabbitMQ знает что его потребитель получил и обработал сообщение перед его уничтожением, но что происходит когда возникает некая проблема либо с самим сообщением, либо в процессе обработки этого сообщения? Для таких развитий событий RabbitMQ предоставляет два механизма откидывания сообщения обратно его брокеру: `Basic.Reject` и `Basic.Nack`.
Потребитель может выдать подтверждение приёма, его отклонение или отрицательный результат подтверждения приёма сообщения. `Basic.Nack` делает возможным отвержения множества сообщений за раз, в то время как `Basic.Reject` позволяет отвергать за раз только одно сообщение.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230622164212.png)
`Basic.Reject` является неким специфичным для AMQP откликом RPC на доставку сообщения, который информирует имеющегося брокера что полученное сообщение не может быть обработано. Как и `Basic.Ack`, он переносит с собой создаваемый RabbitMQ тег доставки для персонального указания на то сообщение в канале, относительно которого ваш потребитель обращается к RabbitMQ. Когда некий потребитель отвергает сообщение, он может указать RabbitMQ либо уничтожить это сообщение, либо повторно поставить в очередь данное сообщение с соответствующим флагом `requeue`. При включённом значении флага `requeue`, RabbitMQ поместит данное сообщение в соответствующую очередь для повторной обработки. При этом, в сообщении может быть установлен флаг `redelivered`, чтобы следующий получатель знал, что это сообщение изначально не было доставлено и, возможно, нет смысла возвращать его обратно в очередь при повторном возникновении проблем.
`Basic.Reject` делает возможным отклонение отдельного сообщения, однако, если применяется рабочий поток, использующий `Basic.Ack` во множественном режиме, то можно пожелать релизовать тот же самый тип функциональности и для отвержения сообщений с помощью отклика RPC `Basic.Nack` ("negative acknowledgment"). Метод `Basic.Nack` реализует то же самое поведение что и метод отклика `Basic.Reject`, но при этом он добавляет несколько отсутствующих аргументов к множественному поведению `Basic.Ack`.
<p class="note">Выступая в качестве частного дополнения RabbitMQ для протокола AMQP, `Basic.Nack` не гарантирует его присутствия в прочих брокерах AMQP, таких как QPID или ActiveMQ. Кроме того, обычные клиенты AMQP без расширений особенностей протокола RabbitMQ также не поддерживают его.</p>

Свойство обмена пропавшими сообщениями (DLX, dead-letter exchange) RabbitMQ является расширением имеющейся спецификации AMQP и выступает в роли необязательного поведения, которое осуществляет попытку отвергать недоставленные сообщения. Это свойство полезно при попытке диагностирования проблем при потреблении определённых сообщений. Это обычный обмен и единственное, что делает его обменом пропавшими письмами - это объявление использования данного обмена для отклонённых сообщений при создании очереди. При отказе от сообщения, в котором отпала необходимость, RabbitMQ выполнит маршрутизацию данного сообщения в соответствующий обмен, определяемый в данной очереди как аргумент `x-dead-letter`. [Пример](https://gist.github.com/quiver/3844767)
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230622205905.png)
<p class="note">Обмен пропавшими письмами не то же самое что и Альтернативный обмен. Письмо с истекшим сроком или отклонённое письмо доставляется через обмен пропавших писем, в то время как Альтернативный обмен направляет сообщения, которые в противном случае не прошли бы маршрутизацию RabbitMQ.</p>
Помимо собственно обмена, данная функциональность потерянных писем позволяет  переписывать имеющийся ключ маршрутизации предопределённым значением. Это делает возможным применять тот же самый обмен для сообщений о пропавших письмах, что и для сообщений с непропавшими письмами, но при этом гарантировать что такие сообщения пропавших писем не доставляются в ту же самую очередь. Для установки предварительно заданного ключа маршрутизации требуется определять при объявлении такой очереди дополнительный аргумент  `x-dead-letter-routing-key`.
```python
channel.queue_declare(queue='task_queue',
	arguments={
	'x-message-ttl' : 1000,
	"x-dead-letter-exchange" : "dlx",
	# "x-dead-letter-routing-key" : "dl", # if not specified, queue's routing-key is used
}
```
<p class="note">Согласно стандарта AMQP, все настройки очереди в RabbitMQ являются неизменными, что означает, что их нельзя изменять после объявления . Для внесения изменения обмена пропавшими письмами в какой-то очереди, следует её удалить и повторно объявить.</p>

При определении очереди имеется множество установок, которые определяют поведение очереди. Вот некоторые возможости очереди:
- Автоматически удалять себя
- Разрешать для себя только одного потребителя
- Автоматически завершать срок действия сообщения
- Придерживаться ограниченного числа очередей
- Выпихивать старые сообщения из стека

RabbitMQ предоставляет для очередей возможность самостоятельного самоудаления после того, как в ней  больше нет потребности. После того как потребители соединились, выбрали все сообщения и все отсоединились, данная очередь может быть удалена. Создание автоматически удаляющейся очереди выполняется устанокой флага `auto_delete` в значение `True` в RPC запросе `Queue.Declare`
```python
result :Method = channel.queue_declare(queue='', exclusive=True, auto_delete=True)
```

Очередь, объявленная как `exclusive`, может потребляться только в том же самом соединении и в том же самом канале в котором она была объявлена. При отсутствии включённой установки `exclusive` очереди не устанавливают ограничений на общее число потребителей, которые могут соединяться с ними. Исключительная очередь также будет автоматически удалена после закрытия канала, для которого была создана. В отличие от очереди `auto_delete` , к очереди `exclusive` потребители могут подключаться и отключаться сколько угодно, пока не будет закрыт сам канал. Важно также отметить, что автоматическое удаление очереди `exclusive` происходит вне зависимости от того был ли вызван запрос `Basic.Consume`, в отличие от очереди `auto-delete`.

Также можно создавать очередь, которая обратится к RabbitMQ за удалением если она становится не используемой на протяжении определённого промежутка времени. Для этого при объявлении очереди используется аргумент `x-expires` со значением времени жизни очереди (TTL, time to live), задаваемым в миллисекундах
```python
 arguments={'x-expires': 1000}
```
Для очередей с истекающим временем жизни имеется ряд строгих правил:
- Данная очередь может израсходовать своё время существования только если она не имеет никаких потребителей. Если у вас есть некая очередь с подключёнными потребителями, она будет автоматически удаляться только когда они вызовут `Basic.Cancel` или отсоединятся.
- Срок жизни данной очереди может завершиться только в случае если не было запроса `Basic.Get` для значения продолжительности TTL. Как только для очереди был выполнен хотя бы один запрос `Basic.Get` с неким значением срока годности, текущее значение установки времени жизни обнуляется и эта очередь больше не будет автоматически удаляться.
- Как и в любой другой очереди, параметры и аргументы, объявленные с аргументом `x-expires` не могут быть переопределены или изменены.
- RabbitMQ не предоставляет гарантий того, насколько быстро он удалит такую очередь после истечения её срока жизни.

При объявлении очереди, которая должна выдерживать перезапуски сервера необходимо настроить значение флага `durable` равным `True`. Часто постоянство (durability) очереди путают с оставлением (persistence) сообщений. Cообщения сохраняются на диск в случае, когда сообщение публикуется со свойством `delivery-mode` установленным в значение `2`. Значение флага `durable`, напротив, указывает RabbitMQ что необходимо иметь данную очередь настроенной пока не будет вызван запрос `Queue.Delete`.
```python
channel = connection.channel()
channel.queue_declare(queue='task_queue', durable=True)
```

Для не являющихся критически важными сообщений зачастую лучше чтобы они автоматически исчезали прочь если они слишком долго висят не будучи употреблёнными. Установки TTL для сообщений делают возможными ограничения для серверной стороны в максимальном возрасте сообщения. Очереди с объявленными одновременно и обменом потерянных писем (DLX), и со значением TTL, повлекут к тому, что сообщения пропавших писем в данной очереди будут иметь срок жизни.
В отличие от свойства истечения срока сообщения, значение которого может меняться от сообщения к сообщению, установки очереди `x-message-ttl` задают максимальный возраст для всех сообщений в данной очереди.
```python
channel = connection.channel()
this=channel.queue_declare(queue='hello',
                            arguments={'x-message-ttl' : 1000}
                            )
```

Очереди можно задать максимальный размер. Если установить значение аргумента `x-max-length` для очереди, то когда она достигнет своего максимального размера, RabbitMQ будет удалять сообщения из передней части этой очереди по мере добавления новых сообщений. Т.е. всегда будут доступно не более `_n_` самых последних сообщений. Удаляемые из передней части очереди сообщения могут относиться к потерянным сообщениям если данная очередь объявляется с exchange потерянных сообщений.
```python
channel.queue_declare(
    queue='hello',
    arguments={'x-max-length': 5}
)
```

Спецификация AMQP определяет аргументы очереди как некую таблицу, в которой сами синтаксис и семантика её значений должна быть определена основным сервером. RabbitMQ имеет зарезервированные аргументы, перечисляемые в следующей таблице, и игнорирует все прочие передаваемые ему аргументы. Аргументы могут иметь только допустимые типы данных AMQP.

|Название аргумента|Назначение|
|---|---|
|**`x-dead-letter-exchange`**|обмен, в который направляются отвергнутые сообщения, которые не поставлены повторно в очередь|
|**`x-dead-letter-routing-key`**|Не обязательный ключ маршрутизации для сообщений потерянных писем|
|**`x-expires`**|Очередь удаляется после заданного числа миллисекунд|
|**`x-ha-policy`**|При создании очередей с высокой доступностью определяет режим принудительной HA по узлам|
|**`x-ha-nodes`**|Те узлы, на которые распространяется некая очередь HA|
|**`x-max-length`**|Максимальное число сообщений в очереди|
|**`x-message-ttl`**|Время истечения срока жизни сообщения в миллисекундах, применяемое ко всему уровню очереди|
|**`x-max-priority`**|Разрешает сортировку по приоритетам в очереди с максимальным значением приоритета 255 (RabbitMQ версий 3.5.0 и выше)|

# Маршрутизация сообщений
**Прямой обмен**
Прямой обмен полезен когда необходимо доставить сообщение определённому получателю. Любая очередь, которая связывается с неким обменом с помощью того же самого ключа маршрутизации, который применяется для публикации сообщения получит это сообщение. RabbitMQ проверяет эквивалентность строк при связывании и не позволяет использования шаблонов соответствий  при прямом обмене. Множество очередей может связываться с прямым обменом при помощи одного и того же ключа маршрутизации. Каждая такая очередь будет получать все те сообщения, которые публикуются с соответствующим ключом маршрутизации.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230623093404.png)
```python
channel = connection.channel()
channel.exchange_declare("direct_logs", exchange_type="direct")
```
Допустим, необходимо реализовать некую службу API на веб-основе, которая обрабатывает выкладываемые с мобильного телефона фотографии. Архитектура, указанная выше, позволяет создать облегчённые, масштабируемые, асинхронные веб приложения. После запуска веб-приложения, оно создаст в RabbitMQ некую очередь с применением названия, уникального для этих процессов откликов RPC.
Как показано на следующем рисунке, процесс запроса начинается когда мобильное приложение загружает изображение, и вэб-приложение его получает. Затем приложение создаёт сообщение с уникальным идентификатором, который указывает на удалённый запрос. При публикации этого изображения в exchange, в соответствующем поле `reply-to` будет установлено название очереди отклика, а идентификатор этого отклика будет помещён в поле `correlation-id`. Само тело данного сообщения будет содержать бинарные данные изображения.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230623094639.png)
При таком запросе формируются следующие фреймы:
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230623095007.png)
Изображение, которое подлежит отправке в качестве тела сообщения, разделяется на три фрагмента, отправляемых во фреймах. Максимальный размер фрейма RAbbitMQ составляет 131 072 байт, что означает, что любое сообщение, которое превосходит этот размер будет делиться на фрагменты на уровне протокола AMQP. Так как имеются 7 байт накладных расходов, которые также следует учитывать, фрейм каждого тела может переносить только 131 065 байт двоичных данных.
Создание exchange
```python
channel = connection.channel()
for exchange_name in ['rpc-replies', 'direct-rpc-requests']: 
	channel.exchange_declare(exchange_name, exchange_type="direct")
```
Создание исполнителя (worker) RPC - приложение потребителя, которое будет получать сообщения с изображением и затем его обрабатывать. После завершения обработки, полученная новая картинка публикуется обратно через RabbitMQ при помощи информации, предоставляемой в свойствах полученного первоначально сообщения.
```python
channel = connection.channel()
for exchange_name in ['rpc-replies', 'direct-rpc-requests']: 
	channel.exchange_declare(exchange_name, exchange_type="direct")
result: Method = channel.queue_declare('direct-rpc-requests', 
									   auto_delete=True, 
									   durable=False, 
									   exclusive=True)
queue_name = result.method.queue
channel.queue_bind(queue_name, 'direct-rpc-requests', 'detect-faces')
channel.basic_consume(queue=queue_name, on_message_callback=callback)

def callback(ch, method, properties, body):

	# обработка изображения из body

	result_file = "ready image"
	
    ch.basic_publish(exchange='rpc-replies', 
                    routing_key=properties.reply_to,
                    properties=pika.BasicProperties(
	                    app_id = 'Image consumer',
	                    content_type = properties.content_type,
                        correlation_id = properties.correlation_id,
                        headers = {
						  'first_publish': properties.timestamp
						}
                    ),
                    body=str(response)
                    )
    ch.basic_ack(delivery_tag=method.delivery_tag)
    
channel.start_consuming()
```
Создание продюсера

**Широковещательные сообщения**
Все публикуемые через веерный обмен сообщения доставляются во все очереди в таком веерном обмене. Это предоставляет значительные преимущества в производительности так как RabitMQ не требуется вычислять ключ маршрутизации для доставки сообщений, однако утрата селективности означает, что все потребляющие приложения из связанных с веерным обменом очередей должны иметь возможность потреблять доставляемые им сообщения.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230623145608.png)

```python
# producer
channel = connecton.channel()
channel.exchange_declare("logs", exchange_type="fanout")
channel.basic_publish(exchange="logs", routing_key='', body="message")
connecton.close()
```
```python
# consumer
channel = connection.channel()
channel.exchange_declare(exchange="logs", exchange_type="fanout")
result = channel.queue_declare("", exclusive=True)
queue_name = result.method.queue
channel.queue_bind(exchange="logs", queue=queue_name)
def callback(ch, method, properties, body):
	print('[x] %r'%body)
channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True)
channel.start_consuming()
```

**Topic exchange**
Как и в случае прямого обмена, topic exchange будет направлять сообщения в любую связанную с ключом маршрутизации очередь. Применяя формат с разграничением точкой, очереди могут привязываться ключами маршрутизации при помощи шаблонов подстановки. Применяя символы звёздочки (`*`) и решётки (`#`) можно сделать шаблон маршрута. Звёздочка может заменить ровно одно слово, а символ решётки сможет заменить ноль или более слов. 
На рисунке некий ключ маршрутизации предметного обмена с тремя частями, которые вы можете применять для маршрутизации изображений. Самая первая часть указывает на сообщение, которое следует маршрутизировать потребителям, которые знают как поступать с относящимся к изображениям сообщениям. Вторая часть указывает что сообщение содержит новое изображение, а третья содержит дополнительные данные, которые могут применяться для направления такого сообщения в очереди потребителей, которые являются особенными для связанной с профилем функциональностью.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230623151129.png)
В результате сообщения выборочно направляются в различные очереди на основе объединения их ключей маршрутизации
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230623151456.png)
```python
# producer
channel = connection.channel()
channel.exchange_declare("topic_logs", exchange_type="topic")
channel.basic_publish(exchange="topic_logs", routing_key='anonymous.info', body="message")
connection.close()
```
```python
# consumer
channel = connection.channel()
channel.exchange_declare(exchange='topic_logs', exchange_type="topic")
result:Method = channel.queue_declare('', exclusive=True)
queue_name = result.method.queue
channel.queue_bind(queue=queue_name, exchange='topic_logs', routing_key='*.info')
def callback(ch, method, properties, body):
	print(" [x] %r:%r" % (method.routing_key, body))
channel.basic_consume(queue=queue_name, on_message_callback=callback, auto_ack=True) 
channel.start_consuming()
	```

**Выборочная маршрутизация сообщений при помощи обмена заголовками**
Обмен заголовками делает возможной произвольную маршрутизацию с применением таблицы `headers`. Привязываемые к обмену заголовками очереди применяют параметр `arguments` в `Queue.Bind` для передачи словаря для маршрутизации, а также аргумент `x-match`. Этот аргумент `x-match` является строковым значением, которое устанавливается в `any` или `all`. Если его значением является `any`, сообщения будут направляться если любое из значение таблицы `headers` соответствует любому имеющемуся связанному значению. Если же значением `x-match` является `all`, все значения, передаваемые как аргументы `Queue.Bind` должны совпадать. 
```python
# producer
import pika 
import sys 
connection = pika.BlockingConnection(
									 pika.ConnectionParameters(
									 host='localhost')
									 ) 
channel = connection.channel() 
channel.exchange_declare(exchange='testing', type='headers') 
fields = {} 
try: 
	while True: 
		data = raw_input('> ') 
		if '=' in data: 
			key, val = data.split('=') 
			fields[key] = val 
			continue 
	channel.basic_publish(exchange = 'testing', 
					  routing_key = '', 
					  body = data, 
					  properties = pika.BasicProperties(headers = fields)
					  ) 
	print ' [x] Send {0} with headers: {1}'.format(data, fields) 
except KeyboardInterrupt: 
	print 'Bye' 
finally: connection.close()
```
```python
# consumer
import pika 
import sys 
connection = pika.BlockingConnection(pika.ConnectionParameters(															   host='localhost')) 			channel = connection.channel() 
channel.exchange_declare(exchange='testing', type='headers') 
result = channel.queue_declare(exclusive=True) 
if not result: 
	print 'Queue didnt declare properly!' 
	sys.exit(1) 
queue_name = result.method.queue 
channel.queue_bind(exchange='testing', 
				   queue = queue_name, 
				   routing_key = '', 
				   arguments = {'x-match': 'all',
                         'source': 'profile',
                         'object': 'image',
                         'action': 'new'}
                )
 	   
def callback(ch, method, properties, body): 
	print "{headers}:{body}".format(
		headers = properties.headers, body = body) channel.basic_consume(callback, queue = queue_name, no_ack=True) 
try: 
	channel.start_consuming() 
except KeyboardInterrupt: 
	print 'Bye' 
finally: connection.close()
```
Хотя обмен заголовками создаёт дополнительную гибкость при соответствиях возможностей `any` и `all`, он приводит с дополнительным накладным расходам вычислений при выполнении маршрутизации. И в производительности он проигрывает topic exchange.

**маршрутизация exchange-to-exchange**
Команда RabbitMQ добавила в RabbitMQ очень гибкий механизм, которого нет в имеющейся спецификации AMQP, и который позволяет выполнять маршрутизацию сообщений практически в любой комбинации обменов. Этот механизм для связывания exchange-to-exchange очень похож на связывание с очередью, но вместо привязки какой-то очереди к обмену, связывается один обмен к другому обмену, применяя метод `Exchange.Bind`.
При применении связывания exchange-to-exchange логика маршрутизации остаётся той же, как если бы этот прикрепляемый объект был очередью. Любой обмен может быть прикреплён к другому обмену, включая все типы встроенных обменов. Такая функциональность позволяет сцеплять обмены всеми мыслимыми способами. Однако вместе с такой гибкостью приходит дополнительная сложность поддержки и диагностики.
<br> <br> ![pic](https://github.com/dave502/RabbitMQ/blob/main/images/Pasted%20image%2020230623155511.png)
```python
conn_str = "amqp://:@127.0.0.1:5432/vhost"
params = pika.URLParameters(conn_str)
connection = pika.BlockingConnection(params)
channel = connection.channel()
channel.exchange_declare(exchange='parent_exchange', exchange_type='fanout')
channel.exchange_declare(exchange='child_exchange', exchange_type='direct')
channel.exchange_bind(destination='child_exchange', 
					  source='parent_exchange', 
					  routing_key='routing_key')
channel.close()
connection.close()
```

**Обмен с согласованным хэшированием**
Обмен с согласованным хэшированием может применяться для балансировки нагрузки подключённых очередей. Вместо того чтобы очереди связывались некими ключами маршрутизации или значениями заголовка, они связываются с весом на основе целочисленного значения, которое применяется как часть общего алгоритма для определения получателя сообщения.
[Пример](https://github.com/rabbitmq/rabbitmq-consistent-hash-exchange/blob/master/examples/python/example1.py)
```python
import pika
import time

conn = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))
ch = conn.channel()
ch.exchange_declare(exchange="e", 
					exchange_type="x-consistent-hash", 
					durable=True)
for q in ['q1', 'q2', 'q3', 'q4']:
    ch.queue_declare(queue=q, durable=True)
    ch.queue_purge(queue=q)

for q in ['q1', 'q2']:
    ch.queue_bind(exchange='e2', queue=q, routing_key='1') #очереди c весом 1
for q in ['q3', 'q4']:
    ch.queue_bind(exchange='e2', queue=q, routing_key='2') #очереди c весом 2
"""
.....
"""

```
Как правило, прибегать к согласованному хэшированию нет необходимости. Однако если требуется выполнять такие задачи, как распределение подмножеств сообщений по центрам обработки данных или кластерам RabbitMQ, обмен с согласованным кэшированием может стать подходящим инструментом.

**Итоговый список типов обмена**

|Название|Подключаемый модуль|Описание|
|---|---|---|
|**`Direct`**  <br>(Прямой)|Нет|Маршрутизация связывания очередей на основе определённого значения ключа маршрутизации. Реализует только соответствия на эквивалентность.|
|**`Fanout`**  <br>(Веерный)|Нет|Направляет во все связанные очереди вне зависимости от установленного ключа маршрутизации, представленного в сообщении|
|**`Topic`**  <br>(Предметный)|Нет|Направляет во все связанные очереди при помощи шаблона ключа маршрутизации и эквивалентности строк.|
|**`Headers`**  <br>(Заголовков)|Нет|Нправляет сообщения в связанные очереди на основе имеющихся в таблице свойства `headers` данного сообщения.|
|**`Consistent-hashing`**  <br>(Согласованного хэширования)|Да|Ведёт себя аналогично веерному обмену, однако для направления в связанные очереди распространяет сообщения основываясь на значении имеющегося хэша ключа маршрутизации или начения заголовка свойств сообщения.|
